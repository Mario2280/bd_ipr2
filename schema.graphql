# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AccountCreateNestedOneWithoutClientInput {
  connect: AccountWhereUniqueInput
  connectOrCreate: AccountCreateOrConnectWithoutClientInput
  create: AccountCreateWithoutClientInput
}

input AccountCreateOrConnectWithoutClientInput {
  create: AccountCreateWithoutClientInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutClientInput {
  account_number: String!
  balance: String!
  bank_name: String!
  credit_amount: Float!
  date: Timestamp!
  has_credit: Boolean!
}

input AccountNullableRelationFilter {
  is: AccountWhereInput
  isNot: AccountWhereInput
}

input AccountOrderByWithRelationInput {
  account_number: SortOrder
  balance: SortOrder
  bank_name: SortOrder
  client: ClientOrderByWithRelationInput
  client_id: SortOrder
  credit_amount: SortOrder
  date: SortOrder
  has_credit: SortOrder
  id: SortOrder
}

input AccountUpdateOneWithoutClientNestedInput {
  connect: AccountWhereUniqueInput
  connectOrCreate: AccountCreateOrConnectWithoutClientInput
  create: AccountCreateWithoutClientInput
  delete: AccountWhereInput
  disconnect: AccountWhereInput
  update: AccountUpdateToOneWithWhereWithoutClientInput
  upsert: AccountUpsertWithoutClientInput
}

input AccountUpdateToOneWithWhereWithoutClientInput {
  data: AccountUpdateWithoutClientInput!
  where: AccountWhereInput
}

input AccountUpdateWithoutClientInput {
  account_number: StringFieldUpdateOperationsInput
  balance: StringFieldUpdateOperationsInput
  bank_name: StringFieldUpdateOperationsInput
  credit_amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  has_credit: BoolFieldUpdateOperationsInput
}

input AccountUpsertWithoutClientInput {
  create: AccountCreateWithoutClientInput!
  update: AccountUpdateWithoutClientInput!
  where: AccountWhereInput
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  account_number: StringFilter
  balance: StringFilter
  bank_name: StringFilter
  client: ClientRelationFilter
  client_id: IntFilter
  credit_amount: FloatFilter
  date: DateTimeFilter
  has_credit: BoolFilter
  id: IntFilter
}

input AccountWhereUniqueInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  account_number: StringFilter
  balance: StringFilter
  bank_name: StringFilter
  client: ClientRelationFilter
  client_id: Int
  credit_amount: FloatFilter
  date: DateTimeFilter
  has_credit: BoolFilter
  id: Int
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateClient {
  _avg: ClientAvgAggregate
  _count: ClientCountAggregate
  _max: ClientMaxAggregate
  _min: ClientMinAggregate
  _sum: ClientSumAggregate
}

type AggregateCompany {
  _avg: CompanyAvgAggregate
  _count: CompanyCountAggregate
  _max: CompanyMaxAggregate
  _min: CompanyMinAggregate
  _sum: CompanySumAggregate
}

type AggregateInvoice {
  _avg: InvoiceAvgAggregate
  _count: InvoiceCountAggregate
  _max: InvoiceMaxAggregate
  _min: InvoiceMinAggregate
  _sum: InvoiceSumAggregate
}

type AggregateOrder {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
}

type AggregateProduct {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
}

type AggregateStaff {
  _avg: StaffAvgAggregate
  _count: StaffCountAggregate
  _max: StaffMaxAggregate
  _min: StaffMinAggregate
  _sum: StaffSumAggregate
}

type AggregateSupplier {
  _avg: SupplierAvgAggregate
  _count: SupplierCountAggregate
  _max: SupplierMaxAggregate
  _min: SupplierMinAggregate
  _sum: SupplierSumAggregate
}

type AggregateTransport {
  _avg: TransportAvgAggregate
  _count: TransportCountAggregate
  _max: TransportMaxAggregate
  _min: TransportMinAggregate
  _sum: TransportSumAggregate
}

type AggregateWarehouse {
  _avg: WarehouseAvgAggregate
  _count: WarehouseCountAggregate
  _max: WarehouseMaxAggregate
  _min: WarehouseMinAggregate
  _sum: WarehouseSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Client {
  _count: ClientCount
  address: String!
  id: Int!
  name: String!
}

type ClientAvgAggregate {
  id: Float
}

input ClientAvgOrderByAggregateInput {
  id: SortOrder
}

type ClientCount {
  orders(where: OrderWhereInput): Int!
}

type ClientCountAggregate {
  _all: Int!
  address: Int!
  id: Int!
  name: Int!
}

input ClientCountOrderByAggregateInput {
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input ClientCreateInput {
  account: AccountCreateNestedOneWithoutClientInput
  address: String!
  name: String!
  orders: OrderCreateNestedManyWithoutClientInput
}

input ClientCreateManyInput {
  address: String!
  id: Int
  name: String!
}

input ClientCreateNestedOneWithoutOrdersInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutOrdersInput
  create: ClientCreateWithoutOrdersInput
}

input ClientCreateOrConnectWithoutOrdersInput {
  create: ClientCreateWithoutOrdersInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutOrdersInput {
  account: AccountCreateNestedOneWithoutClientInput
  address: String!
  name: String!
}

type ClientGroupBy {
  _avg: ClientAvgAggregate
  _count: ClientCountAggregate
  _max: ClientMaxAggregate
  _min: ClientMinAggregate
  _sum: ClientSumAggregate
  address: String!
  id: Int!
  name: String!
}

type ClientMaxAggregate {
  address: String
  id: Int
  name: String
}

input ClientMaxOrderByAggregateInput {
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

type ClientMinAggregate {
  address: String
  id: Int
  name: String
}

input ClientMinOrderByAggregateInput {
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input ClientOrderByWithAggregationInput {
  _avg: ClientAvgOrderByAggregateInput
  _count: ClientCountOrderByAggregateInput
  _max: ClientMaxOrderByAggregateInput
  _min: ClientMinOrderByAggregateInput
  _sum: ClientSumOrderByAggregateInput
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input ClientOrderByWithRelationInput {
  account: AccountOrderByWithRelationInput
  address: SortOrder
  id: SortOrder
  name: SortOrder
  orders: OrderOrderByRelationAggregateInput
}

input ClientRelationFilter {
  is: ClientWhereInput
  isNot: ClientWhereInput
}

enum ClientScalarFieldEnum {
  address
  id
  name
}

input ClientScalarWhereWithAggregatesInput {
  AND: [ClientScalarWhereWithAggregatesInput!]
  NOT: [ClientScalarWhereWithAggregatesInput!]
  OR: [ClientScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type ClientSumAggregate {
  id: Int
}

input ClientSumOrderByAggregateInput {
  id: SortOrder
}

input ClientUpdateInput {
  account: AccountUpdateOneWithoutClientNestedInput
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orders: OrderUpdateManyWithoutClientNestedInput
}

input ClientUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ClientUpdateOneRequiredWithoutOrdersNestedInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutOrdersInput
  create: ClientCreateWithoutOrdersInput
  update: ClientUpdateToOneWithWhereWithoutOrdersInput
  upsert: ClientUpsertWithoutOrdersInput
}

input ClientUpdateToOneWithWhereWithoutOrdersInput {
  data: ClientUpdateWithoutOrdersInput!
  where: ClientWhereInput
}

input ClientUpdateWithoutOrdersInput {
  account: AccountUpdateOneWithoutClientNestedInput
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ClientUpsertWithoutOrdersInput {
  create: ClientCreateWithoutOrdersInput!
  update: ClientUpdateWithoutOrdersInput!
  where: ClientWhereInput
}

input ClientWhereInput {
  AND: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  account: AccountNullableRelationFilter
  address: StringFilter
  id: IntFilter
  name: StringFilter
  orders: OrderListRelationFilter
}

input ClientWhereUniqueInput {
  AND: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  account: AccountNullableRelationFilter
  address: StringFilter
  id: Int
  name: StringFilter
  orders: OrderListRelationFilter
}

type Company {
  _count: CompanyCount
  address: String!
  bank_account: String!
  id: Int!
  name: String!
  phone: String!
}

type CompanyAvgAggregate {
  id: Float
}

input CompanyAvgOrderByAggregateInput {
  id: SortOrder
}

type CompanyCount {
  invoices(where: InvoiceWhereInput): Int!
  staffes(where: StaffWhereInput): Int!
  transports(where: TransportWhereInput): Int!
  warehouses(where: WarehouseWhereInput): Int!
}

type CompanyCountAggregate {
  _all: Int!
  address: Int!
  bank_account: Int!
  id: Int!
  name: Int!
  phone: Int!
}

input CompanyCountOrderByAggregateInput {
  address: SortOrder
  bank_account: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CompanyCreateInput {
  address: String!
  bank_account: String!
  invoices: InvoiceCreateNestedManyWithoutCompanyInput
  name: String!
  phone: String!
  staffes: StaffCreateNestedManyWithoutCompanyInput
  transports: TransportCreateNestedManyWithoutCompanyInput
  warehouses: WarehouseCreateNestedManyWithoutCompanyInput
}

input CompanyCreateManyInput {
  address: String!
  bank_account: String!
  id: Int
  name: String!
  phone: String!
}

input CompanyCreateNestedOneWithoutInvoicesInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutInvoicesInput
  create: CompanyCreateWithoutInvoicesInput
}

input CompanyCreateNestedOneWithoutStaffesInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutStaffesInput
  create: CompanyCreateWithoutStaffesInput
}

input CompanyCreateNestedOneWithoutTransportsInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutTransportsInput
  create: CompanyCreateWithoutTransportsInput
}

input CompanyCreateNestedOneWithoutWarehousesInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutWarehousesInput
  create: CompanyCreateWithoutWarehousesInput
}

input CompanyCreateOrConnectWithoutInvoicesInput {
  create: CompanyCreateWithoutInvoicesInput!
  where: CompanyWhereUniqueInput!
}

input CompanyCreateOrConnectWithoutStaffesInput {
  create: CompanyCreateWithoutStaffesInput!
  where: CompanyWhereUniqueInput!
}

input CompanyCreateOrConnectWithoutTransportsInput {
  create: CompanyCreateWithoutTransportsInput!
  where: CompanyWhereUniqueInput!
}

input CompanyCreateOrConnectWithoutWarehousesInput {
  create: CompanyCreateWithoutWarehousesInput!
  where: CompanyWhereUniqueInput!
}

input CompanyCreateWithoutInvoicesInput {
  address: String!
  bank_account: String!
  name: String!
  phone: String!
  staffes: StaffCreateNestedManyWithoutCompanyInput
  transports: TransportCreateNestedManyWithoutCompanyInput
  warehouses: WarehouseCreateNestedManyWithoutCompanyInput
}

input CompanyCreateWithoutStaffesInput {
  address: String!
  bank_account: String!
  invoices: InvoiceCreateNestedManyWithoutCompanyInput
  name: String!
  phone: String!
  transports: TransportCreateNestedManyWithoutCompanyInput
  warehouses: WarehouseCreateNestedManyWithoutCompanyInput
}

input CompanyCreateWithoutTransportsInput {
  address: String!
  bank_account: String!
  invoices: InvoiceCreateNestedManyWithoutCompanyInput
  name: String!
  phone: String!
  staffes: StaffCreateNestedManyWithoutCompanyInput
  warehouses: WarehouseCreateNestedManyWithoutCompanyInput
}

input CompanyCreateWithoutWarehousesInput {
  address: String!
  bank_account: String!
  invoices: InvoiceCreateNestedManyWithoutCompanyInput
  name: String!
  phone: String!
  staffes: StaffCreateNestedManyWithoutCompanyInput
  transports: TransportCreateNestedManyWithoutCompanyInput
}

type CompanyGroupBy {
  _avg: CompanyAvgAggregate
  _count: CompanyCountAggregate
  _max: CompanyMaxAggregate
  _min: CompanyMinAggregate
  _sum: CompanySumAggregate
  address: String!
  bank_account: String!
  id: Int!
  name: String!
  phone: String!
}

type CompanyMaxAggregate {
  address: String
  bank_account: String
  id: Int
  name: String
  phone: String
}

input CompanyMaxOrderByAggregateInput {
  address: SortOrder
  bank_account: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

type CompanyMinAggregate {
  address: String
  bank_account: String
  id: Int
  name: String
  phone: String
}

input CompanyMinOrderByAggregateInput {
  address: SortOrder
  bank_account: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CompanyOrderByWithAggregationInput {
  _avg: CompanyAvgOrderByAggregateInput
  _count: CompanyCountOrderByAggregateInput
  _max: CompanyMaxOrderByAggregateInput
  _min: CompanyMinOrderByAggregateInput
  _sum: CompanySumOrderByAggregateInput
  address: SortOrder
  bank_account: SortOrder
  id: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  bank_account: SortOrder
  id: SortOrder
  invoices: InvoiceOrderByRelationAggregateInput
  name: SortOrder
  phone: SortOrder
  staffes: StaffOrderByRelationAggregateInput
  transports: TransportOrderByRelationAggregateInput
  warehouses: WarehouseOrderByRelationAggregateInput
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  address
  bank_account
  id
  name
  phone
}

input CompanyScalarWhereWithAggregatesInput {
  AND: [CompanyScalarWhereWithAggregatesInput!]
  NOT: [CompanyScalarWhereWithAggregatesInput!]
  OR: [CompanyScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  bank_account: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
}

type CompanySumAggregate {
  id: Int
}

input CompanySumOrderByAggregateInput {
  id: SortOrder
}

input CompanyUpdateInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutCompanyNestedInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  staffes: StaffUpdateManyWithoutCompanyNestedInput
  transports: TransportUpdateManyWithoutCompanyNestedInput
  warehouses: WarehouseUpdateManyWithoutCompanyNestedInput
}

input CompanyUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
}

input CompanyUpdateOneRequiredWithoutInvoicesNestedInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutInvoicesInput
  create: CompanyCreateWithoutInvoicesInput
  update: CompanyUpdateToOneWithWhereWithoutInvoicesInput
  upsert: CompanyUpsertWithoutInvoicesInput
}

input CompanyUpdateOneRequiredWithoutStaffesNestedInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutStaffesInput
  create: CompanyCreateWithoutStaffesInput
  update: CompanyUpdateToOneWithWhereWithoutStaffesInput
  upsert: CompanyUpsertWithoutStaffesInput
}

input CompanyUpdateOneRequiredWithoutTransportsNestedInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutTransportsInput
  create: CompanyCreateWithoutTransportsInput
  update: CompanyUpdateToOneWithWhereWithoutTransportsInput
  upsert: CompanyUpsertWithoutTransportsInput
}

input CompanyUpdateOneRequiredWithoutWarehousesNestedInput {
  connect: CompanyWhereUniqueInput
  connectOrCreate: CompanyCreateOrConnectWithoutWarehousesInput
  create: CompanyCreateWithoutWarehousesInput
  update: CompanyUpdateToOneWithWhereWithoutWarehousesInput
  upsert: CompanyUpsertWithoutWarehousesInput
}

input CompanyUpdateToOneWithWhereWithoutInvoicesInput {
  data: CompanyUpdateWithoutInvoicesInput!
  where: CompanyWhereInput
}

input CompanyUpdateToOneWithWhereWithoutStaffesInput {
  data: CompanyUpdateWithoutStaffesInput!
  where: CompanyWhereInput
}

input CompanyUpdateToOneWithWhereWithoutTransportsInput {
  data: CompanyUpdateWithoutTransportsInput!
  where: CompanyWhereInput
}

input CompanyUpdateToOneWithWhereWithoutWarehousesInput {
  data: CompanyUpdateWithoutWarehousesInput!
  where: CompanyWhereInput
}

input CompanyUpdateWithoutInvoicesInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  staffes: StaffUpdateManyWithoutCompanyNestedInput
  transports: TransportUpdateManyWithoutCompanyNestedInput
  warehouses: WarehouseUpdateManyWithoutCompanyNestedInput
}

input CompanyUpdateWithoutStaffesInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutCompanyNestedInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  transports: TransportUpdateManyWithoutCompanyNestedInput
  warehouses: WarehouseUpdateManyWithoutCompanyNestedInput
}

input CompanyUpdateWithoutTransportsInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutCompanyNestedInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  staffes: StaffUpdateManyWithoutCompanyNestedInput
  warehouses: WarehouseUpdateManyWithoutCompanyNestedInput
}

input CompanyUpdateWithoutWarehousesInput {
  address: StringFieldUpdateOperationsInput
  bank_account: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutCompanyNestedInput
  name: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  staffes: StaffUpdateManyWithoutCompanyNestedInput
  transports: TransportUpdateManyWithoutCompanyNestedInput
}

input CompanyUpsertWithoutInvoicesInput {
  create: CompanyCreateWithoutInvoicesInput!
  update: CompanyUpdateWithoutInvoicesInput!
  where: CompanyWhereInput
}

input CompanyUpsertWithoutStaffesInput {
  create: CompanyCreateWithoutStaffesInput!
  update: CompanyUpdateWithoutStaffesInput!
  where: CompanyWhereInput
}

input CompanyUpsertWithoutTransportsInput {
  create: CompanyCreateWithoutTransportsInput!
  update: CompanyUpdateWithoutTransportsInput!
  where: CompanyWhereInput
}

input CompanyUpsertWithoutWarehousesInput {
  create: CompanyCreateWithoutWarehousesInput!
  update: CompanyUpdateWithoutWarehousesInput!
  where: CompanyWhereInput
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  bank_account: StringFilter
  id: IntFilter
  invoices: InvoiceListRelationFilter
  name: StringFilter
  phone: StringFilter
  staffes: StaffListRelationFilter
  transports: TransportListRelationFilter
  warehouses: WarehouseListRelationFilter
}

input CompanyWhereUniqueInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  bank_account: StringFilter
  id: Int
  invoices: InvoiceListRelationFilter
  name: StringFilter
  phone: StringFilter
  staffes: StaffListRelationFilter
  transports: TransportListRelationFilter
  warehouses: WarehouseListRelationFilter
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Invoice {
  company_id: Int!
  id: Int!
  order_id: Int!
  product_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

type InvoiceAvgAggregate {
  company_id: Float
  id: Float
  order_id: Float
  product_id: Float
  product_quantity: Float
  total_amount: Float
}

input InvoiceAvgOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

type InvoiceCountAggregate {
  _all: Int!
  company_id: Int!
  id: Int!
  order_id: Int!
  product_id: Int!
  product_name: Int!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCountOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

input InvoiceCreateInput {
  company: CompanyCreateNestedOneWithoutInvoicesInput!
  order: OrderCreateNestedOneWithoutInvoiceInput!
  product: ProductCreateNestedOneWithoutInvoicesInput!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateManyCompanyInput {
  id: Int
  order_id: Int!
  product_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateManyCompanyInputEnvelope {
  data: [InvoiceCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input InvoiceCreateManyInput {
  company_id: Int!
  id: Int
  order_id: Int!
  product_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateManyOrderInput {
  company_id: Int!
  id: Int
  product_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateManyOrderInputEnvelope {
  data: [InvoiceCreateManyOrderInput!]!
  skipDuplicates: Boolean
}

input InvoiceCreateManyProductInput {
  company_id: Int!
  id: Int
  order_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateManyProductInputEnvelope {
  data: [InvoiceCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input InvoiceCreateNestedManyWithoutCompanyInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutCompanyInput!]
  create: [InvoiceCreateWithoutCompanyInput!]
  createMany: InvoiceCreateManyCompanyInputEnvelope
}

input InvoiceCreateNestedManyWithoutOrderInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutOrderInput!]
  create: [InvoiceCreateWithoutOrderInput!]
  createMany: InvoiceCreateManyOrderInputEnvelope
}

input InvoiceCreateNestedManyWithoutProductInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutProductInput!]
  create: [InvoiceCreateWithoutProductInput!]
  createMany: InvoiceCreateManyProductInputEnvelope
}

input InvoiceCreateOrConnectWithoutCompanyInput {
  create: InvoiceCreateWithoutCompanyInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceCreateOrConnectWithoutOrderInput {
  create: InvoiceCreateWithoutOrderInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceCreateOrConnectWithoutProductInput {
  create: InvoiceCreateWithoutProductInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceCreateWithoutCompanyInput {
  order: OrderCreateNestedOneWithoutInvoiceInput!
  product: ProductCreateNestedOneWithoutInvoicesInput!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateWithoutOrderInput {
  company: CompanyCreateNestedOneWithoutInvoicesInput!
  product: ProductCreateNestedOneWithoutInvoicesInput!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceCreateWithoutProductInput {
  company: CompanyCreateNestedOneWithoutInvoicesInput!
  order: OrderCreateNestedOneWithoutInvoiceInput!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

type InvoiceGroupBy {
  _avg: InvoiceAvgAggregate
  _count: InvoiceCountAggregate
  _max: InvoiceMaxAggregate
  _min: InvoiceMinAggregate
  _sum: InvoiceSumAggregate
  company_id: Int!
  id: Int!
  order_id: Int!
  product_id: Int!
  product_name: String!
  product_quantity: Int!
  total_amount: Int!
}

input InvoiceListRelationFilter {
  every: InvoiceWhereInput
  none: InvoiceWhereInput
  some: InvoiceWhereInput
}

type InvoiceMaxAggregate {
  company_id: Int
  id: Int
  order_id: Int
  product_id: Int
  product_name: String
  product_quantity: Int
  total_amount: Int
}

input InvoiceMaxOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

type InvoiceMinAggregate {
  company_id: Int
  id: Int
  order_id: Int
  product_id: Int
  product_name: String
  product_quantity: Int
  total_amount: Int
}

input InvoiceMinOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

input InvoiceOrderByRelationAggregateInput {
  _count: SortOrder
}

input InvoiceOrderByWithAggregationInput {
  _avg: InvoiceAvgOrderByAggregateInput
  _count: InvoiceCountOrderByAggregateInput
  _max: InvoiceMaxOrderByAggregateInput
  _min: InvoiceMinOrderByAggregateInput
  _sum: InvoiceSumOrderByAggregateInput
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

input InvoiceOrderByWithRelationInput {
  company: CompanyOrderByWithRelationInput
  company_id: SortOrder
  id: SortOrder
  order: OrderOrderByWithRelationInput
  order_id: SortOrder
  product: ProductOrderByWithRelationInput
  product_id: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

enum InvoiceScalarFieldEnum {
  company_id
  id
  order_id
  product_id
  product_name
  product_quantity
  total_amount
}

input InvoiceScalarWhereInput {
  AND: [InvoiceScalarWhereInput!]
  NOT: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  company_id: IntFilter
  id: IntFilter
  order_id: IntFilter
  product_id: IntFilter
  product_name: StringFilter
  product_quantity: IntFilter
  total_amount: IntFilter
}

input InvoiceScalarWhereWithAggregatesInput {
  AND: [InvoiceScalarWhereWithAggregatesInput!]
  NOT: [InvoiceScalarWhereWithAggregatesInput!]
  OR: [InvoiceScalarWhereWithAggregatesInput!]
  company_id: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  order_id: IntWithAggregatesFilter
  product_id: IntWithAggregatesFilter
  product_name: StringWithAggregatesFilter
  product_quantity: IntWithAggregatesFilter
  total_amount: IntWithAggregatesFilter
}

type InvoiceSumAggregate {
  company_id: Int
  id: Int
  order_id: Int
  product_id: Int
  product_quantity: Int
  total_amount: Int
}

input InvoiceSumOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
  product_id: SortOrder
  product_quantity: SortOrder
  total_amount: SortOrder
}

input InvoiceUpdateInput {
  company: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  order: OrderUpdateOneRequiredWithoutInvoiceNestedInput
  product: ProductUpdateOneRequiredWithoutInvoicesNestedInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  total_amount: IntFieldUpdateOperationsInput
}

input InvoiceUpdateManyMutationInput {
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  total_amount: IntFieldUpdateOperationsInput
}

input InvoiceUpdateManyWithWhereWithoutCompanyInput {
  data: InvoiceUpdateManyMutationInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateManyWithWhereWithoutOrderInput {
  data: InvoiceUpdateManyMutationInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateManyWithWhereWithoutProductInput {
  data: InvoiceUpdateManyMutationInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateManyWithoutCompanyNestedInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutCompanyInput!]
  create: [InvoiceCreateWithoutCompanyInput!]
  createMany: InvoiceCreateManyCompanyInputEnvelope
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutCompanyInput!]
  updateMany: [InvoiceUpdateManyWithWhereWithoutCompanyInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutCompanyInput!]
}

input InvoiceUpdateManyWithoutOrderNestedInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutOrderInput!]
  create: [InvoiceCreateWithoutOrderInput!]
  createMany: InvoiceCreateManyOrderInputEnvelope
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutOrderInput!]
  updateMany: [InvoiceUpdateManyWithWhereWithoutOrderInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutOrderInput!]
}

input InvoiceUpdateManyWithoutProductNestedInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutProductInput!]
  create: [InvoiceCreateWithoutProductInput!]
  createMany: InvoiceCreateManyProductInputEnvelope
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [InvoiceUpdateManyWithWhereWithoutProductInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutProductInput!]
}

input InvoiceUpdateWithWhereUniqueWithoutCompanyInput {
  data: InvoiceUpdateWithoutCompanyInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithWhereUniqueWithoutOrderInput {
  data: InvoiceUpdateWithoutOrderInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithWhereUniqueWithoutProductInput {
  data: InvoiceUpdateWithoutProductInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithoutCompanyInput {
  order: OrderUpdateOneRequiredWithoutInvoiceNestedInput
  product: ProductUpdateOneRequiredWithoutInvoicesNestedInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  total_amount: IntFieldUpdateOperationsInput
}

input InvoiceUpdateWithoutOrderInput {
  company: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  product: ProductUpdateOneRequiredWithoutInvoicesNestedInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  total_amount: IntFieldUpdateOperationsInput
}

input InvoiceUpdateWithoutProductInput {
  company: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  order: OrderUpdateOneRequiredWithoutInvoiceNestedInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  total_amount: IntFieldUpdateOperationsInput
}

input InvoiceUpsertWithWhereUniqueWithoutCompanyInput {
  create: InvoiceCreateWithoutCompanyInput!
  update: InvoiceUpdateWithoutCompanyInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertWithWhereUniqueWithoutOrderInput {
  create: InvoiceCreateWithoutOrderInput!
  update: InvoiceUpdateWithoutOrderInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertWithWhereUniqueWithoutProductInput {
  create: InvoiceCreateWithoutProductInput!
  update: InvoiceUpdateWithoutProductInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceWhereInput {
  AND: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  id: IntFilter
  order: OrderRelationFilter
  order_id: IntFilter
  product: ProductRelationFilter
  product_id: IntFilter
  product_name: StringFilter
  product_quantity: IntFilter
  total_amount: IntFilter
}

input InvoiceWhereUniqueInput {
  AND: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  id: Int
  order: OrderRelationFilter
  order_id: IntFilter
  product: ProductRelationFilter
  product_id: IntFilter
  product_name: StringFilter
  product_quantity: IntFilter
  total_amount: IntFilter
}

type Mutation {
  createManyClient(data: [ClientCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCompany(data: [CompanyCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInvoice(data: [InvoiceCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOrder(data: [OrderCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProduct(data: [ProductCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyStaff(data: [StaffCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySupplier(data: [SupplierCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTransport(data: [TransportCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWarehouse(data: [WarehouseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneClient(data: ClientCreateInput!, relationLoadStrategy: RelationLoadStrategy): Client!
  createOneCompany(data: CompanyCreateInput!, relationLoadStrategy: RelationLoadStrategy): Company!
  createOneInvoice(data: InvoiceCreateInput!, relationLoadStrategy: RelationLoadStrategy): Invoice!
  createOneOrder(data: OrderCreateInput!, relationLoadStrategy: RelationLoadStrategy): Order!
  createOneProduct(data: ProductCreateInput!, relationLoadStrategy: RelationLoadStrategy): Product!
  createOneStaff(data: StaffCreateInput!, relationLoadStrategy: RelationLoadStrategy): Staff!
  createOneSupplier(data: SupplierCreateInput!, relationLoadStrategy: RelationLoadStrategy): Supplier!
  createOneTransport(data: TransportCreateInput!, relationLoadStrategy: RelationLoadStrategy): Transport!
  createOneWarehouse(data: WarehouseCreateInput!, relationLoadStrategy: RelationLoadStrategy): Warehouse!
  deleteManyClient(where: ClientWhereInput): AffectedRowsOutput!
  deleteManyCompany(where: CompanyWhereInput): AffectedRowsOutput!
  deleteManyInvoice(where: InvoiceWhereInput): AffectedRowsOutput!
  deleteManyOrder(where: OrderWhereInput): AffectedRowsOutput!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyStaff(where: StaffWhereInput): AffectedRowsOutput!
  deleteManySupplier(where: SupplierWhereInput): AffectedRowsOutput!
  deleteManyTransport(where: TransportWhereInput): AffectedRowsOutput!
  deleteManyWarehouse(where: WarehouseWhereInput): AffectedRowsOutput!
  deleteOneClient(relationLoadStrategy: RelationLoadStrategy, where: ClientWhereUniqueInput!): Client
  deleteOneCompany(relationLoadStrategy: RelationLoadStrategy, where: CompanyWhereUniqueInput!): Company
  deleteOneInvoice(relationLoadStrategy: RelationLoadStrategy, where: InvoiceWhereUniqueInput!): Invoice
  deleteOneOrder(relationLoadStrategy: RelationLoadStrategy, where: OrderWhereUniqueInput!): Order
  deleteOneProduct(relationLoadStrategy: RelationLoadStrategy, where: ProductWhereUniqueInput!): Product
  deleteOneStaff(relationLoadStrategy: RelationLoadStrategy, where: StaffWhereUniqueInput!): Staff
  deleteOneSupplier(relationLoadStrategy: RelationLoadStrategy, where: SupplierWhereUniqueInput!): Supplier
  deleteOneTransport(relationLoadStrategy: RelationLoadStrategy, where: TransportWhereUniqueInput!): Transport
  deleteOneWarehouse(relationLoadStrategy: RelationLoadStrategy, where: WarehouseWhereUniqueInput!): Warehouse
  updateManyClient(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): AffectedRowsOutput!
  updateManyCompany(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): AffectedRowsOutput!
  updateManyInvoice(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): AffectedRowsOutput!
  updateManyOrder(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): AffectedRowsOutput!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyStaff(data: StaffUpdateManyMutationInput!, where: StaffWhereInput): AffectedRowsOutput!
  updateManySupplier(data: SupplierUpdateManyMutationInput!, where: SupplierWhereInput): AffectedRowsOutput!
  updateManyTransport(data: TransportUpdateManyMutationInput!, where: TransportWhereInput): AffectedRowsOutput!
  updateManyWarehouse(data: WarehouseUpdateManyMutationInput!, where: WarehouseWhereInput): AffectedRowsOutput!
  updateOneClient(data: ClientUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: ClientWhereUniqueInput!): Client
  updateOneCompany(data: CompanyUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: CompanyWhereUniqueInput!): Company
  updateOneInvoice(data: InvoiceUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: InvoiceWhereUniqueInput!): Invoice
  updateOneOrder(data: OrderUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: OrderWhereUniqueInput!): Order
  updateOneProduct(data: ProductUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: ProductWhereUniqueInput!): Product
  updateOneStaff(data: StaffUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: StaffWhereUniqueInput!): Staff
  updateOneSupplier(data: SupplierUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: SupplierWhereUniqueInput!): Supplier
  updateOneTransport(data: TransportUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: TransportWhereUniqueInput!): Transport
  updateOneWarehouse(data: WarehouseUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: WarehouseWhereUniqueInput!): Warehouse
  upsertOneClient(create: ClientCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client!
  upsertOneCompany(create: CompanyCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company!
  upsertOneInvoice(create: InvoiceCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice!
  upsertOneOrder(create: OrderCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order!
  upsertOneProduct(create: ProductCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneStaff(create: StaffCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: StaffUpdateInput!, where: StaffWhereUniqueInput!): Staff!
  upsertOneSupplier(create: SupplierCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: SupplierUpdateInput!, where: SupplierWhereUniqueInput!): Supplier!
  upsertOneTransport(create: TransportCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: TransportUpdateInput!, where: TransportWhereUniqueInput!): Transport!
  upsertOneWarehouse(create: WarehouseCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: WarehouseUpdateInput!, where: WarehouseWhereUniqueInput!): Warehouse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Order {
  _count: OrderCount
  client_id: Int!
  id: Int!
  order_date: Timestamp!
  product_count: Int!
  product_id: Int!
}

type OrderAvgAggregate {
  client_id: Float
  id: Float
  product_count: Float
  product_id: Float
}

input OrderAvgOrderByAggregateInput {
  client_id: SortOrder
  id: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

type OrderCount {
  Invoice(where: InvoiceWhereInput): Int!
  Warehouse(where: WarehouseWhereInput): Int!
}

type OrderCountAggregate {
  _all: Int!
  client_id: Int!
  id: Int!
  order_date: Int!
  product_count: Int!
  product_id: Int!
}

input OrderCountOrderByAggregateInput {
  client_id: SortOrder
  id: SortOrder
  order_date: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

input OrderCreateInput {
  Invoice: InvoiceCreateNestedManyWithoutOrderInput
  Warehouse: WarehouseCreateNestedManyWithoutOrderInput
  client: ClientCreateNestedOneWithoutOrdersInput!
  order_date: Timestamp!
  product: ProductCreateNestedOneWithoutOrderInput!
  product_count: Int!
}

input OrderCreateManyClientInput {
  id: Int
  order_date: Timestamp!
  product_count: Int!
  product_id: Int!
}

input OrderCreateManyClientInputEnvelope {
  data: [OrderCreateManyClientInput!]!
  skipDuplicates: Boolean
}

input OrderCreateManyInput {
  client_id: Int!
  id: Int
  order_date: Timestamp!
  product_count: Int!
  product_id: Int!
}

input OrderCreateManyProductInput {
  client_id: Int!
  id: Int
  order_date: Timestamp!
  product_count: Int!
}

input OrderCreateManyProductInputEnvelope {
  data: [OrderCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input OrderCreateNestedManyWithoutClientInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutClientInput!]
  create: [OrderCreateWithoutClientInput!]
  createMany: OrderCreateManyClientInputEnvelope
}

input OrderCreateNestedManyWithoutProductInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutProductInput!]
  create: [OrderCreateWithoutProductInput!]
  createMany: OrderCreateManyProductInputEnvelope
}

input OrderCreateNestedOneWithoutInvoiceInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutInvoiceInput
  create: OrderCreateWithoutInvoiceInput
}

input OrderCreateNestedOneWithoutWarehouseInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutWarehouseInput
  create: OrderCreateWithoutWarehouseInput
}

input OrderCreateOrConnectWithoutClientInput {
  create: OrderCreateWithoutClientInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutInvoiceInput {
  create: OrderCreateWithoutInvoiceInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutProductInput {
  create: OrderCreateWithoutProductInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutWarehouseInput {
  create: OrderCreateWithoutWarehouseInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateWithoutClientInput {
  Invoice: InvoiceCreateNestedManyWithoutOrderInput
  Warehouse: WarehouseCreateNestedManyWithoutOrderInput
  order_date: Timestamp!
  product: ProductCreateNestedOneWithoutOrderInput!
  product_count: Int!
}

input OrderCreateWithoutInvoiceInput {
  Warehouse: WarehouseCreateNestedManyWithoutOrderInput
  client: ClientCreateNestedOneWithoutOrdersInput!
  order_date: Timestamp!
  product: ProductCreateNestedOneWithoutOrderInput!
  product_count: Int!
}

input OrderCreateWithoutProductInput {
  Invoice: InvoiceCreateNestedManyWithoutOrderInput
  Warehouse: WarehouseCreateNestedManyWithoutOrderInput
  client: ClientCreateNestedOneWithoutOrdersInput!
  order_date: Timestamp!
  product_count: Int!
}

input OrderCreateWithoutWarehouseInput {
  Invoice: InvoiceCreateNestedManyWithoutOrderInput
  client: ClientCreateNestedOneWithoutOrdersInput!
  order_date: Timestamp!
  product: ProductCreateNestedOneWithoutOrderInput!
  product_count: Int!
}

type OrderGroupBy {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
  client_id: Int!
  id: Int!
  order_date: Timestamp!
  product_count: Int!
  product_id: Int!
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

type OrderMaxAggregate {
  client_id: Int
  id: Int
  order_date: Timestamp
  product_count: Int
  product_id: Int
}

input OrderMaxOrderByAggregateInput {
  client_id: SortOrder
  id: SortOrder
  order_date: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

type OrderMinAggregate {
  client_id: Int
  id: Int
  order_date: Timestamp
  product_count: Int
  product_id: Int
}

input OrderMinOrderByAggregateInput {
  client_id: SortOrder
  id: SortOrder
  order_date: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

input OrderOrderByRelationAggregateInput {
  _count: SortOrder
}

input OrderOrderByWithAggregationInput {
  _avg: OrderAvgOrderByAggregateInput
  _count: OrderCountOrderByAggregateInput
  _max: OrderMaxOrderByAggregateInput
  _min: OrderMinOrderByAggregateInput
  _sum: OrderSumOrderByAggregateInput
  client_id: SortOrder
  id: SortOrder
  order_date: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

input OrderOrderByWithRelationInput {
  Invoice: InvoiceOrderByRelationAggregateInput
  Warehouse: WarehouseOrderByRelationAggregateInput
  client: ClientOrderByWithRelationInput
  client_id: SortOrder
  id: SortOrder
  order_date: SortOrder
  product: ProductOrderByWithRelationInput
  product_count: SortOrder
  product_id: SortOrder
}

input OrderRelationFilter {
  is: OrderWhereInput
  isNot: OrderWhereInput
}

enum OrderScalarFieldEnum {
  client_id
  id
  order_date
  product_count
  product_id
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  client_id: IntFilter
  id: IntFilter
  order_date: DateTimeFilter
  product_count: IntFilter
  product_id: IntFilter
}

input OrderScalarWhereWithAggregatesInput {
  AND: [OrderScalarWhereWithAggregatesInput!]
  NOT: [OrderScalarWhereWithAggregatesInput!]
  OR: [OrderScalarWhereWithAggregatesInput!]
  client_id: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  order_date: DateTimeWithAggregatesFilter
  product_count: IntWithAggregatesFilter
  product_id: IntWithAggregatesFilter
}

type OrderSumAggregate {
  client_id: Int
  id: Int
  product_count: Int
  product_id: Int
}

input OrderSumOrderByAggregateInput {
  client_id: SortOrder
  id: SortOrder
  product_count: SortOrder
  product_id: SortOrder
}

input OrderUpdateInput {
  Invoice: InvoiceUpdateManyWithoutOrderNestedInput
  Warehouse: WarehouseUpdateManyWithoutOrderNestedInput
  client: ClientUpdateOneRequiredWithoutOrdersNestedInput
  order_date: DateTimeFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrderNestedInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpdateManyMutationInput {
  order_date: DateTimeFieldUpdateOperationsInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpdateManyWithWhereWithoutClientInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateManyWithWhereWithoutProductInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateManyWithoutClientNestedInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutClientInput!]
  create: [OrderCreateWithoutClientInput!]
  createMany: OrderCreateManyClientInputEnvelope
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutClientInput!]
  updateMany: [OrderUpdateManyWithWhereWithoutClientInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutClientInput!]
}

input OrderUpdateManyWithoutProductNestedInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutProductInput!]
  create: [OrderCreateWithoutProductInput!]
  createMany: OrderCreateManyProductInputEnvelope
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [OrderUpdateManyWithWhereWithoutProductInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutProductInput!]
}

input OrderUpdateOneRequiredWithoutInvoiceNestedInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutInvoiceInput
  create: OrderCreateWithoutInvoiceInput
  update: OrderUpdateToOneWithWhereWithoutInvoiceInput
  upsert: OrderUpsertWithoutInvoiceInput
}

input OrderUpdateOneRequiredWithoutWarehouseNestedInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutWarehouseInput
  create: OrderCreateWithoutWarehouseInput
  update: OrderUpdateToOneWithWhereWithoutWarehouseInput
  upsert: OrderUpsertWithoutWarehouseInput
}

input OrderUpdateToOneWithWhereWithoutInvoiceInput {
  data: OrderUpdateWithoutInvoiceInput!
  where: OrderWhereInput
}

input OrderUpdateToOneWithWhereWithoutWarehouseInput {
  data: OrderUpdateWithoutWarehouseInput!
  where: OrderWhereInput
}

input OrderUpdateWithWhereUniqueWithoutClientInput {
  data: OrderUpdateWithoutClientInput!
  where: OrderWhereUniqueInput!
}

input OrderUpdateWithWhereUniqueWithoutProductInput {
  data: OrderUpdateWithoutProductInput!
  where: OrderWhereUniqueInput!
}

input OrderUpdateWithoutClientInput {
  Invoice: InvoiceUpdateManyWithoutOrderNestedInput
  Warehouse: WarehouseUpdateManyWithoutOrderNestedInput
  order_date: DateTimeFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrderNestedInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpdateWithoutInvoiceInput {
  Warehouse: WarehouseUpdateManyWithoutOrderNestedInput
  client: ClientUpdateOneRequiredWithoutOrdersNestedInput
  order_date: DateTimeFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrderNestedInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpdateWithoutProductInput {
  Invoice: InvoiceUpdateManyWithoutOrderNestedInput
  Warehouse: WarehouseUpdateManyWithoutOrderNestedInput
  client: ClientUpdateOneRequiredWithoutOrdersNestedInput
  order_date: DateTimeFieldUpdateOperationsInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpdateWithoutWarehouseInput {
  Invoice: InvoiceUpdateManyWithoutOrderNestedInput
  client: ClientUpdateOneRequiredWithoutOrdersNestedInput
  order_date: DateTimeFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrderNestedInput
  product_count: IntFieldUpdateOperationsInput
}

input OrderUpsertWithWhereUniqueWithoutClientInput {
  create: OrderCreateWithoutClientInput!
  update: OrderUpdateWithoutClientInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithWhereUniqueWithoutProductInput {
  create: OrderCreateWithoutProductInput!
  update: OrderUpdateWithoutProductInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithoutInvoiceInput {
  create: OrderCreateWithoutInvoiceInput!
  update: OrderUpdateWithoutInvoiceInput!
  where: OrderWhereInput
}

input OrderUpsertWithoutWarehouseInput {
  create: OrderCreateWithoutWarehouseInput!
  update: OrderUpdateWithoutWarehouseInput!
  where: OrderWhereInput
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  Invoice: InvoiceListRelationFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  Warehouse: WarehouseListRelationFilter
  client: ClientRelationFilter
  client_id: IntFilter
  id: IntFilter
  order_date: DateTimeFilter
  product: ProductRelationFilter
  product_count: IntFilter
  product_id: IntFilter
}

input OrderWhereUniqueInput {
  AND: [OrderWhereInput!]
  Invoice: InvoiceListRelationFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  Warehouse: WarehouseListRelationFilter
  client: ClientRelationFilter
  client_id: IntFilter
  id: Int
  order_date: DateTimeFilter
  product: ProductRelationFilter
  product_count: IntFilter
  product_id: IntFilter
}

type Product {
  _count: ProductCount
  grade: String!
  id: Int!
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier_id: Int!
  unit_of_measurement: String!
}

type ProductAvgAggregate {
  id: Float
  price: Float
  product_quantity: Float
  supplier_id: Float
}

input ProductAvgOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
}

type ProductCount {
  Order(where: OrderWhereInput): Int!
  invoices(where: InvoiceWhereInput): Int!
}

type ProductCountAggregate {
  _all: Int!
  grade: Int!
  id: Int!
  manufacturer: Int!
  manufacturer_address: Int!
  price: Int!
  product_name: Int!
  product_quantity: Int!
  supplier_id: Int!
  unit_of_measurement: Int!
}

input ProductCountOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  manufacturer: SortOrder
  manufacturer_address: SortOrder
  price: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
  unit_of_measurement: SortOrder
}

input ProductCreateInput {
  Order: OrderCreateNestedManyWithoutProductInput
  grade: String!
  invoices: InvoiceCreateNestedManyWithoutProductInput
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier: SupplierCreateNestedOneWithoutProductsInput!
  unit_of_measurement: String!
}

input ProductCreateManyInput {
  grade: String!
  id: Int
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier_id: Int!
  unit_of_measurement: String!
}

input ProductCreateManySupplierInput {
  grade: String!
  id: Int
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  unit_of_measurement: String!
}

input ProductCreateManySupplierInputEnvelope {
  data: [ProductCreateManySupplierInput!]!
  skipDuplicates: Boolean
}

input ProductCreateNestedManyWithoutSupplierInput {
  connect: [ProductWhereUniqueInput!]
  connectOrCreate: [ProductCreateOrConnectWithoutSupplierInput!]
  create: [ProductCreateWithoutSupplierInput!]
  createMany: ProductCreateManySupplierInputEnvelope
}

input ProductCreateNestedOneWithoutInvoicesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInvoicesInput
  create: ProductCreateWithoutInvoicesInput
}

input ProductCreateNestedOneWithoutOrderInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrderInput
  create: ProductCreateWithoutOrderInput
}

input ProductCreateOrConnectWithoutInvoicesInput {
  create: ProductCreateWithoutInvoicesInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutOrderInput {
  create: ProductCreateWithoutOrderInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutSupplierInput {
  create: ProductCreateWithoutSupplierInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutInvoicesInput {
  Order: OrderCreateNestedManyWithoutProductInput
  grade: String!
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier: SupplierCreateNestedOneWithoutProductsInput!
  unit_of_measurement: String!
}

input ProductCreateWithoutOrderInput {
  grade: String!
  invoices: InvoiceCreateNestedManyWithoutProductInput
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier: SupplierCreateNestedOneWithoutProductsInput!
  unit_of_measurement: String!
}

input ProductCreateWithoutSupplierInput {
  Order: OrderCreateNestedManyWithoutProductInput
  grade: String!
  invoices: InvoiceCreateNestedManyWithoutProductInput
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  unit_of_measurement: String!
}

type ProductGroupBy {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
  grade: String!
  id: Int!
  manufacturer: String!
  manufacturer_address: String!
  price: Float!
  product_name: String!
  product_quantity: Int!
  supplier_id: Int!
  unit_of_measurement: String!
}

input ProductListRelationFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

type ProductMaxAggregate {
  grade: String
  id: Int
  manufacturer: String
  manufacturer_address: String
  price: Float
  product_name: String
  product_quantity: Int
  supplier_id: Int
  unit_of_measurement: String
}

input ProductMaxOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  manufacturer: SortOrder
  manufacturer_address: SortOrder
  price: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
  unit_of_measurement: SortOrder
}

type ProductMinAggregate {
  grade: String
  id: Int
  manufacturer: String
  manufacturer_address: String
  price: Float
  product_name: String
  product_quantity: Int
  supplier_id: Int
  unit_of_measurement: String
}

input ProductMinOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  manufacturer: SortOrder
  manufacturer_address: SortOrder
  price: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
  unit_of_measurement: SortOrder
}

input ProductOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductOrderByWithAggregationInput {
  _avg: ProductAvgOrderByAggregateInput
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  _sum: ProductSumOrderByAggregateInput
  grade: SortOrder
  id: SortOrder
  manufacturer: SortOrder
  manufacturer_address: SortOrder
  price: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
  unit_of_measurement: SortOrder
}

input ProductOrderByWithRelationInput {
  Order: OrderOrderByRelationAggregateInput
  grade: SortOrder
  id: SortOrder
  invoices: InvoiceOrderByRelationAggregateInput
  manufacturer: SortOrder
  manufacturer_address: SortOrder
  price: SortOrder
  product_name: SortOrder
  product_quantity: SortOrder
  supplier: SupplierOrderByWithRelationInput
  supplier_id: SortOrder
  unit_of_measurement: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

enum ProductScalarFieldEnum {
  grade
  id
  manufacturer
  manufacturer_address
  price
  product_name
  product_quantity
  supplier_id
  unit_of_measurement
}

input ProductScalarWhereInput {
  AND: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  grade: StringFilter
  id: IntFilter
  manufacturer: StringFilter
  manufacturer_address: StringFilter
  price: FloatFilter
  product_name: StringFilter
  product_quantity: IntFilter
  supplier_id: IntFilter
  unit_of_measurement: StringFilter
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  grade: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  manufacturer: StringWithAggregatesFilter
  manufacturer_address: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  product_name: StringWithAggregatesFilter
  product_quantity: IntWithAggregatesFilter
  supplier_id: IntWithAggregatesFilter
  unit_of_measurement: StringWithAggregatesFilter
}

type ProductSumAggregate {
  id: Int
  price: Float
  product_quantity: Int
  supplier_id: Int
}

input ProductSumOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  product_quantity: SortOrder
  supplier_id: SortOrder
}

input ProductUpdateInput {
  Order: OrderUpdateManyWithoutProductNestedInput
  grade: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutProductNestedInput
  manufacturer: StringFieldUpdateOperationsInput
  manufacturer_address: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  supplier: SupplierUpdateOneRequiredWithoutProductsNestedInput
  unit_of_measurement: StringFieldUpdateOperationsInput
}

input ProductUpdateManyMutationInput {
  grade: StringFieldUpdateOperationsInput
  manufacturer: StringFieldUpdateOperationsInput
  manufacturer_address: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  unit_of_measurement: StringFieldUpdateOperationsInput
}

input ProductUpdateManyWithWhereWithoutSupplierInput {
  data: ProductUpdateManyMutationInput!
  where: ProductScalarWhereInput!
}

input ProductUpdateManyWithoutSupplierNestedInput {
  connect: [ProductWhereUniqueInput!]
  connectOrCreate: [ProductCreateOrConnectWithoutSupplierInput!]
  create: [ProductCreateWithoutSupplierInput!]
  createMany: ProductCreateManySupplierInputEnvelope
  delete: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutSupplierInput!]
  updateMany: [ProductUpdateManyWithWhereWithoutSupplierInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutSupplierInput!]
}

input ProductUpdateOneRequiredWithoutInvoicesNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInvoicesInput
  create: ProductCreateWithoutInvoicesInput
  update: ProductUpdateToOneWithWhereWithoutInvoicesInput
  upsert: ProductUpsertWithoutInvoicesInput
}

input ProductUpdateOneRequiredWithoutOrderNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrderInput
  create: ProductCreateWithoutOrderInput
  update: ProductUpdateToOneWithWhereWithoutOrderInput
  upsert: ProductUpsertWithoutOrderInput
}

input ProductUpdateToOneWithWhereWithoutInvoicesInput {
  data: ProductUpdateWithoutInvoicesInput!
  where: ProductWhereInput
}

input ProductUpdateToOneWithWhereWithoutOrderInput {
  data: ProductUpdateWithoutOrderInput!
  where: ProductWhereInput
}

input ProductUpdateWithWhereUniqueWithoutSupplierInput {
  data: ProductUpdateWithoutSupplierInput!
  where: ProductWhereUniqueInput!
}

input ProductUpdateWithoutInvoicesInput {
  Order: OrderUpdateManyWithoutProductNestedInput
  grade: StringFieldUpdateOperationsInput
  manufacturer: StringFieldUpdateOperationsInput
  manufacturer_address: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  supplier: SupplierUpdateOneRequiredWithoutProductsNestedInput
  unit_of_measurement: StringFieldUpdateOperationsInput
}

input ProductUpdateWithoutOrderInput {
  grade: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutProductNestedInput
  manufacturer: StringFieldUpdateOperationsInput
  manufacturer_address: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  supplier: SupplierUpdateOneRequiredWithoutProductsNestedInput
  unit_of_measurement: StringFieldUpdateOperationsInput
}

input ProductUpdateWithoutSupplierInput {
  Order: OrderUpdateManyWithoutProductNestedInput
  grade: StringFieldUpdateOperationsInput
  invoices: InvoiceUpdateManyWithoutProductNestedInput
  manufacturer: StringFieldUpdateOperationsInput
  manufacturer_address: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product_quantity: IntFieldUpdateOperationsInput
  unit_of_measurement: StringFieldUpdateOperationsInput
}

input ProductUpsertWithWhereUniqueWithoutSupplierInput {
  create: ProductCreateWithoutSupplierInput!
  update: ProductUpdateWithoutSupplierInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithoutInvoicesInput {
  create: ProductCreateWithoutInvoicesInput!
  update: ProductUpdateWithoutInvoicesInput!
  where: ProductWhereInput
}

input ProductUpsertWithoutOrderInput {
  create: ProductCreateWithoutOrderInput!
  update: ProductUpdateWithoutOrderInput!
  where: ProductWhereInput
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  Order: OrderListRelationFilter
  grade: StringFilter
  id: IntFilter
  invoices: InvoiceListRelationFilter
  manufacturer: StringFilter
  manufacturer_address: StringFilter
  price: FloatFilter
  product_name: StringFilter
  product_quantity: IntFilter
  supplier: SupplierRelationFilter
  supplier_id: IntFilter
  unit_of_measurement: StringFilter
}

input ProductWhereUniqueInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  Order: OrderListRelationFilter
  grade: StringFilter
  id: Int
  invoices: InvoiceListRelationFilter
  manufacturer: StringFilter
  manufacturer_address: StringFilter
  price: FloatFilter
  product_name: StringFilter
  product_quantity: IntFilter
  supplier: SupplierRelationFilter
  supplier_id: IntFilter
  unit_of_measurement: StringFilter
}

type Query {
  aggregateClient(cursor: ClientWhereUniqueInput, orderBy: [ClientOrderByWithRelationInput!], skip: Int, take: Int, where: ClientWhereInput): AggregateClient!
  aggregateCompany(cursor: CompanyWhereUniqueInput, orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): AggregateCompany!
  aggregateInvoice(cursor: InvoiceWhereUniqueInput, orderBy: [InvoiceOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceWhereInput): AggregateInvoice!
  aggregateOrder(cursor: OrderWhereUniqueInput, orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): AggregateOrder!
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateStaff(cursor: StaffWhereUniqueInput, orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): AggregateStaff!
  aggregateSupplier(cursor: SupplierWhereUniqueInput, orderBy: [SupplierOrderByWithRelationInput!], skip: Int, take: Int, where: SupplierWhereInput): AggregateSupplier!
  aggregateTransport(cursor: TransportWhereUniqueInput, orderBy: [TransportOrderByWithRelationInput!], skip: Int, take: Int, where: TransportWhereInput): AggregateTransport!
  aggregateWarehouse(cursor: WarehouseWhereUniqueInput, orderBy: [WarehouseOrderByWithRelationInput!], skip: Int, take: Int, where: WarehouseWhereInput): AggregateWarehouse!
  client(relationLoadStrategy: RelationLoadStrategy, where: ClientWhereUniqueInput!): Client
  clients(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(relationLoadStrategy: RelationLoadStrategy, where: CompanyWhereUniqueInput!): Company
  findFirstClient(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ClientWhereInput): Client
  findFirstClientOrThrow(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ClientWhereInput): Client
  findFirstCompany(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CompanyWhereInput): Company
  findFirstCompanyOrThrow(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CompanyWhereInput): Company
  findFirstInvoice(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: InvoiceWhereInput): Invoice
  findFirstInvoiceOrThrow(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: InvoiceWhereInput): Invoice
  findFirstOrder(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstOrderOrThrow(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductOrThrow(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstStaff(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: StaffWhereInput): Staff
  findFirstStaffOrThrow(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: StaffWhereInput): Staff
  findFirstSupplier(cursor: SupplierWhereUniqueInput, distinct: [SupplierScalarFieldEnum!], orderBy: [SupplierOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SupplierWhereInput): Supplier
  findFirstSupplierOrThrow(cursor: SupplierWhereUniqueInput, distinct: [SupplierScalarFieldEnum!], orderBy: [SupplierOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SupplierWhereInput): Supplier
  findFirstTransport(cursor: TransportWhereUniqueInput, distinct: [TransportScalarFieldEnum!], orderBy: [TransportOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: TransportWhereInput): Transport
  findFirstTransportOrThrow(cursor: TransportWhereUniqueInput, distinct: [TransportScalarFieldEnum!], orderBy: [TransportOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: TransportWhereInput): Transport
  findFirstWarehouse(cursor: WarehouseWhereUniqueInput, distinct: [WarehouseScalarFieldEnum!], orderBy: [WarehouseOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: WarehouseWhereInput): Warehouse
  findFirstWarehouseOrThrow(cursor: WarehouseWhereUniqueInput, distinct: [WarehouseScalarFieldEnum!], orderBy: [WarehouseOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: WarehouseWhereInput): Warehouse
  findManyStaff(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: StaffWhereInput): [Staff!]!
  findUniqueStaff(relationLoadStrategy: RelationLoadStrategy, where: StaffWhereUniqueInput!): Staff
  findUniqueStaffOrThrow(relationLoadStrategy: RelationLoadStrategy, where: StaffWhereUniqueInput!): Staff
  getClient(relationLoadStrategy: RelationLoadStrategy, where: ClientWhereUniqueInput!): Client
  getCompany(relationLoadStrategy: RelationLoadStrategy, where: CompanyWhereUniqueInput!): Company
  getInvoice(relationLoadStrategy: RelationLoadStrategy, where: InvoiceWhereUniqueInput!): Invoice
  getOrder(relationLoadStrategy: RelationLoadStrategy, where: OrderWhereUniqueInput!): Order
  getProduct(relationLoadStrategy: RelationLoadStrategy, where: ProductWhereUniqueInput!): Product
  getSupplier(relationLoadStrategy: RelationLoadStrategy, where: SupplierWhereUniqueInput!): Supplier
  getTransport(relationLoadStrategy: RelationLoadStrategy, where: TransportWhereUniqueInput!): Transport
  getWarehouse(relationLoadStrategy: RelationLoadStrategy, where: WarehouseWhereUniqueInput!): Warehouse
  groupByClient(by: [ClientScalarFieldEnum!]!, having: ClientScalarWhereWithAggregatesInput, orderBy: [ClientOrderByWithAggregationInput!], skip: Int, take: Int, where: ClientWhereInput): [ClientGroupBy!]!
  groupByCompany(by: [CompanyScalarFieldEnum!]!, having: CompanyScalarWhereWithAggregatesInput, orderBy: [CompanyOrderByWithAggregationInput!], skip: Int, take: Int, where: CompanyWhereInput): [CompanyGroupBy!]!
  groupByInvoice(by: [InvoiceScalarFieldEnum!]!, having: InvoiceScalarWhereWithAggregatesInput, orderBy: [InvoiceOrderByWithAggregationInput!], skip: Int, take: Int, where: InvoiceWhereInput): [InvoiceGroupBy!]!
  groupByOrder(by: [OrderScalarFieldEnum!]!, having: OrderScalarWhereWithAggregatesInput, orderBy: [OrderOrderByWithAggregationInput!], skip: Int, take: Int, where: OrderWhereInput): [OrderGroupBy!]!
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByStaff(by: [StaffScalarFieldEnum!]!, having: StaffScalarWhereWithAggregatesInput, orderBy: [StaffOrderByWithAggregationInput!], skip: Int, take: Int, where: StaffWhereInput): [StaffGroupBy!]!
  groupBySupplier(by: [SupplierScalarFieldEnum!]!, having: SupplierScalarWhereWithAggregatesInput, orderBy: [SupplierOrderByWithAggregationInput!], skip: Int, take: Int, where: SupplierWhereInput): [SupplierGroupBy!]!
  groupByTransport(by: [TransportScalarFieldEnum!]!, having: TransportScalarWhereWithAggregatesInput, orderBy: [TransportOrderByWithAggregationInput!], skip: Int, take: Int, where: TransportWhereInput): [TransportGroupBy!]!
  groupByWarehouse(by: [WarehouseScalarFieldEnum!]!, having: WarehouseScalarWhereWithAggregatesInput, orderBy: [WarehouseOrderByWithAggregationInput!], skip: Int, take: Int, where: WarehouseWhereInput): [WarehouseGroupBy!]!
  invoice(relationLoadStrategy: RelationLoadStrategy, where: InvoiceWhereUniqueInput!): Invoice
  invoices(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: InvoiceWhereInput): [Invoice!]!
  order(relationLoadStrategy: RelationLoadStrategy, where: OrderWhereUniqueInput!): Order
  orders(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  product(relationLoadStrategy: RelationLoadStrategy, where: ProductWhereUniqueInput!): Product
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  supplier(relationLoadStrategy: RelationLoadStrategy, where: SupplierWhereUniqueInput!): Supplier
  suppliers(cursor: SupplierWhereUniqueInput, distinct: [SupplierScalarFieldEnum!], orderBy: [SupplierOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SupplierWhereInput): [Supplier!]!
  transport(relationLoadStrategy: RelationLoadStrategy, where: TransportWhereUniqueInput!): Transport
  transports(cursor: TransportWhereUniqueInput, distinct: [TransportScalarFieldEnum!], orderBy: [TransportOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: TransportWhereInput): [Transport!]!
  warehouse(relationLoadStrategy: RelationLoadStrategy, where: WarehouseWhereUniqueInput!): Warehouse
  warehouses(cursor: WarehouseWhereUniqueInput, distinct: [WarehouseScalarFieldEnum!], orderBy: [WarehouseOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: WarehouseWhereInput): [Warehouse!]!
}

enum QueryMode {
  default
  insensitive
}

enum RelationLoadStrategy {
  join
  query
}

enum SortOrder {
  asc
  desc
}

type Staff {
  company_id: Int!
  education: String!
  hire_date: Timestamp!
  id: Int!
  name: String!
  position: String!
  salary: Float!
}

type StaffAvgAggregate {
  company_id: Float
  id: Float
  salary: Float
}

input StaffAvgOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  salary: SortOrder
}

type StaffCountAggregate {
  _all: Int!
  company_id: Int!
  education: Int!
  hire_date: Int!
  id: Int!
  name: Int!
  position: Int!
  salary: Int!
}

input StaffCountOrderByAggregateInput {
  company_id: SortOrder
  education: SortOrder
  hire_date: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  salary: SortOrder
}

input StaffCreateInput {
  company: CompanyCreateNestedOneWithoutStaffesInput!
  education: String!
  hire_date: Timestamp!
  name: String!
  position: String!
  salary: Float!
}

input StaffCreateManyCompanyInput {
  education: String!
  hire_date: Timestamp!
  id: Int
  name: String!
  position: String!
  salary: Float!
}

input StaffCreateManyCompanyInputEnvelope {
  data: [StaffCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input StaffCreateManyInput {
  company_id: Int!
  education: String!
  hire_date: Timestamp!
  id: Int
  name: String!
  position: String!
  salary: Float!
}

input StaffCreateNestedManyWithoutCompanyInput {
  connect: [StaffWhereUniqueInput!]
  connectOrCreate: [StaffCreateOrConnectWithoutCompanyInput!]
  create: [StaffCreateWithoutCompanyInput!]
  createMany: StaffCreateManyCompanyInputEnvelope
}

input StaffCreateOrConnectWithoutCompanyInput {
  create: StaffCreateWithoutCompanyInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateWithoutCompanyInput {
  education: String!
  hire_date: Timestamp!
  name: String!
  position: String!
  salary: Float!
}

type StaffGroupBy {
  _avg: StaffAvgAggregate
  _count: StaffCountAggregate
  _max: StaffMaxAggregate
  _min: StaffMinAggregate
  _sum: StaffSumAggregate
  company_id: Int!
  education: String!
  hire_date: Timestamp!
  id: Int!
  name: String!
  position: String!
  salary: Float!
}

input StaffListRelationFilter {
  every: StaffWhereInput
  none: StaffWhereInput
  some: StaffWhereInput
}

type StaffMaxAggregate {
  company_id: Int
  education: String
  hire_date: Timestamp
  id: Int
  name: String
  position: String
  salary: Float
}

input StaffMaxOrderByAggregateInput {
  company_id: SortOrder
  education: SortOrder
  hire_date: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  salary: SortOrder
}

type StaffMinAggregate {
  company_id: Int
  education: String
  hire_date: Timestamp
  id: Int
  name: String
  position: String
  salary: Float
}

input StaffMinOrderByAggregateInput {
  company_id: SortOrder
  education: SortOrder
  hire_date: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  salary: SortOrder
}

input StaffOrderByRelationAggregateInput {
  _count: SortOrder
}

input StaffOrderByWithAggregationInput {
  _avg: StaffAvgOrderByAggregateInput
  _count: StaffCountOrderByAggregateInput
  _max: StaffMaxOrderByAggregateInput
  _min: StaffMinOrderByAggregateInput
  _sum: StaffSumOrderByAggregateInput
  company_id: SortOrder
  education: SortOrder
  hire_date: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  salary: SortOrder
}

input StaffOrderByWithRelationInput {
  company: CompanyOrderByWithRelationInput
  company_id: SortOrder
  education: SortOrder
  hire_date: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  salary: SortOrder
}

enum StaffScalarFieldEnum {
  company_id
  education
  hire_date
  id
  name
  position
  salary
}

input StaffScalarWhereInput {
  AND: [StaffScalarWhereInput!]
  NOT: [StaffScalarWhereInput!]
  OR: [StaffScalarWhereInput!]
  company_id: IntFilter
  education: StringFilter
  hire_date: DateTimeFilter
  id: IntFilter
  name: StringFilter
  position: StringFilter
  salary: FloatFilter
}

input StaffScalarWhereWithAggregatesInput {
  AND: [StaffScalarWhereWithAggregatesInput!]
  NOT: [StaffScalarWhereWithAggregatesInput!]
  OR: [StaffScalarWhereWithAggregatesInput!]
  company_id: IntWithAggregatesFilter
  education: StringWithAggregatesFilter
  hire_date: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  position: StringWithAggregatesFilter
  salary: FloatWithAggregatesFilter
}

type StaffSumAggregate {
  company_id: Int
  id: Int
  salary: Float
}

input StaffSumOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  salary: SortOrder
}

input StaffUpdateInput {
  company: CompanyUpdateOneRequiredWithoutStaffesNestedInput
  education: StringFieldUpdateOperationsInput
  hire_date: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  salary: FloatFieldUpdateOperationsInput
}

input StaffUpdateManyMutationInput {
  education: StringFieldUpdateOperationsInput
  hire_date: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  salary: FloatFieldUpdateOperationsInput
}

input StaffUpdateManyWithWhereWithoutCompanyInput {
  data: StaffUpdateManyMutationInput!
  where: StaffScalarWhereInput!
}

input StaffUpdateManyWithoutCompanyNestedInput {
  connect: [StaffWhereUniqueInput!]
  connectOrCreate: [StaffCreateOrConnectWithoutCompanyInput!]
  create: [StaffCreateWithoutCompanyInput!]
  createMany: StaffCreateManyCompanyInputEnvelope
  delete: [StaffWhereUniqueInput!]
  deleteMany: [StaffScalarWhereInput!]
  disconnect: [StaffWhereUniqueInput!]
  set: [StaffWhereUniqueInput!]
  update: [StaffUpdateWithWhereUniqueWithoutCompanyInput!]
  updateMany: [StaffUpdateManyWithWhereWithoutCompanyInput!]
  upsert: [StaffUpsertWithWhereUniqueWithoutCompanyInput!]
}

input StaffUpdateWithWhereUniqueWithoutCompanyInput {
  data: StaffUpdateWithoutCompanyInput!
  where: StaffWhereUniqueInput!
}

input StaffUpdateWithoutCompanyInput {
  education: StringFieldUpdateOperationsInput
  hire_date: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  salary: FloatFieldUpdateOperationsInput
}

input StaffUpsertWithWhereUniqueWithoutCompanyInput {
  create: StaffCreateWithoutCompanyInput!
  update: StaffUpdateWithoutCompanyInput!
  where: StaffWhereUniqueInput!
}

input StaffWhereInput {
  AND: [StaffWhereInput!]
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  education: StringFilter
  hire_date: DateTimeFilter
  id: IntFilter
  name: StringFilter
  position: StringFilter
  salary: FloatFilter
}

input StaffWhereUniqueInput {
  AND: [StaffWhereInput!]
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  education: StringFilter
  hire_date: DateTimeFilter
  id: Int
  name: StringFilter
  position: StringFilter
  salary: FloatFilter
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Supplier {
  _count: SupplierCount
  account: String!
  address: String!
  id: Int!
  name: String!
}

type SupplierAvgAggregate {
  id: Float
}

input SupplierAvgOrderByAggregateInput {
  id: SortOrder
}

type SupplierCount {
  products(where: ProductWhereInput): Int!
}

type SupplierCountAggregate {
  _all: Int!
  account: Int!
  address: Int!
  id: Int!
  name: Int!
}

input SupplierCountOrderByAggregateInput {
  account: SortOrder
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input SupplierCreateInput {
  account: String!
  address: String!
  name: String!
  products: ProductCreateNestedManyWithoutSupplierInput
}

input SupplierCreateManyInput {
  account: String!
  address: String!
  id: Int
  name: String!
}

input SupplierCreateNestedOneWithoutProductsInput {
  connect: SupplierWhereUniqueInput
  connectOrCreate: SupplierCreateOrConnectWithoutProductsInput
  create: SupplierCreateWithoutProductsInput
}

input SupplierCreateOrConnectWithoutProductsInput {
  create: SupplierCreateWithoutProductsInput!
  where: SupplierWhereUniqueInput!
}

input SupplierCreateWithoutProductsInput {
  account: String!
  address: String!
  name: String!
}

type SupplierGroupBy {
  _avg: SupplierAvgAggregate
  _count: SupplierCountAggregate
  _max: SupplierMaxAggregate
  _min: SupplierMinAggregate
  _sum: SupplierSumAggregate
  account: String!
  address: String!
  id: Int!
  name: String!
}

type SupplierMaxAggregate {
  account: String
  address: String
  id: Int
  name: String
}

input SupplierMaxOrderByAggregateInput {
  account: SortOrder
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

type SupplierMinAggregate {
  account: String
  address: String
  id: Int
  name: String
}

input SupplierMinOrderByAggregateInput {
  account: SortOrder
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input SupplierOrderByWithAggregationInput {
  _avg: SupplierAvgOrderByAggregateInput
  _count: SupplierCountOrderByAggregateInput
  _max: SupplierMaxOrderByAggregateInput
  _min: SupplierMinOrderByAggregateInput
  _sum: SupplierSumOrderByAggregateInput
  account: SortOrder
  address: SortOrder
  id: SortOrder
  name: SortOrder
}

input SupplierOrderByWithRelationInput {
  account: SortOrder
  address: SortOrder
  id: SortOrder
  name: SortOrder
  products: ProductOrderByRelationAggregateInput
}

input SupplierRelationFilter {
  is: SupplierWhereInput
  isNot: SupplierWhereInput
}

enum SupplierScalarFieldEnum {
  account
  address
  id
  name
}

input SupplierScalarWhereWithAggregatesInput {
  AND: [SupplierScalarWhereWithAggregatesInput!]
  NOT: [SupplierScalarWhereWithAggregatesInput!]
  OR: [SupplierScalarWhereWithAggregatesInput!]
  account: StringWithAggregatesFilter
  address: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type SupplierSumAggregate {
  id: Int
}

input SupplierSumOrderByAggregateInput {
  id: SortOrder
}

input SupplierUpdateInput {
  account: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  products: ProductUpdateManyWithoutSupplierNestedInput
}

input SupplierUpdateManyMutationInput {
  account: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SupplierUpdateOneRequiredWithoutProductsNestedInput {
  connect: SupplierWhereUniqueInput
  connectOrCreate: SupplierCreateOrConnectWithoutProductsInput
  create: SupplierCreateWithoutProductsInput
  update: SupplierUpdateToOneWithWhereWithoutProductsInput
  upsert: SupplierUpsertWithoutProductsInput
}

input SupplierUpdateToOneWithWhereWithoutProductsInput {
  data: SupplierUpdateWithoutProductsInput!
  where: SupplierWhereInput
}

input SupplierUpdateWithoutProductsInput {
  account: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SupplierUpsertWithoutProductsInput {
  create: SupplierCreateWithoutProductsInput!
  update: SupplierUpdateWithoutProductsInput!
  where: SupplierWhereInput
}

input SupplierWhereInput {
  AND: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  account: StringFilter
  address: StringFilter
  id: IntFilter
  name: StringFilter
  products: ProductListRelationFilter
}

input SupplierWhereUniqueInput {
  AND: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  account: StringFilter
  address: StringFilter
  id: Int
  name: StringFilter
  products: ProductListRelationFilter
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type Transport {
  company_id: Int!
  id: Int!
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse_id: Int!
  year_of_manufacture: Int!
}

type TransportAvgAggregate {
  company_id: Float
  id: Float
  load_capacity: Float
  warehouse_id: Float
  year_of_manufacture: Float
}

input TransportAvgOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

type TransportCountAggregate {
  _all: Int!
  company_id: Int!
  id: Int!
  load_capacity: Int!
  owner_name: Int!
  transport_date: Int!
  vehicle_brand: Int!
  vehicle_number: Int!
  warehouse_id: Int!
  year_of_manufacture: Int!
}

input TransportCountOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  owner_name: SortOrder
  transport_date: SortOrder
  vehicle_brand: SortOrder
  vehicle_number: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

input TransportCreateInput {
  company: CompanyCreateNestedOneWithoutTransportsInput!
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse: WarehouseCreateNestedOneWithoutTransportsInput!
  year_of_manufacture: Int!
}

input TransportCreateManyCompanyInput {
  id: Int
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse_id: Int!
  year_of_manufacture: Int!
}

input TransportCreateManyCompanyInputEnvelope {
  data: [TransportCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input TransportCreateManyInput {
  company_id: Int!
  id: Int
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse_id: Int!
  year_of_manufacture: Int!
}

input TransportCreateManyWarehouseInput {
  company_id: Int!
  id: Int
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  year_of_manufacture: Int!
}

input TransportCreateManyWarehouseInputEnvelope {
  data: [TransportCreateManyWarehouseInput!]!
  skipDuplicates: Boolean
}

input TransportCreateNestedManyWithoutCompanyInput {
  connect: [TransportWhereUniqueInput!]
  connectOrCreate: [TransportCreateOrConnectWithoutCompanyInput!]
  create: [TransportCreateWithoutCompanyInput!]
  createMany: TransportCreateManyCompanyInputEnvelope
}

input TransportCreateNestedManyWithoutWarehouseInput {
  connect: [TransportWhereUniqueInput!]
  connectOrCreate: [TransportCreateOrConnectWithoutWarehouseInput!]
  create: [TransportCreateWithoutWarehouseInput!]
  createMany: TransportCreateManyWarehouseInputEnvelope
}

input TransportCreateOrConnectWithoutCompanyInput {
  create: TransportCreateWithoutCompanyInput!
  where: TransportWhereUniqueInput!
}

input TransportCreateOrConnectWithoutWarehouseInput {
  create: TransportCreateWithoutWarehouseInput!
  where: TransportWhereUniqueInput!
}

input TransportCreateWithoutCompanyInput {
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse: WarehouseCreateNestedOneWithoutTransportsInput!
  year_of_manufacture: Int!
}

input TransportCreateWithoutWarehouseInput {
  company: CompanyCreateNestedOneWithoutTransportsInput!
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  year_of_manufacture: Int!
}

type TransportGroupBy {
  _avg: TransportAvgAggregate
  _count: TransportCountAggregate
  _max: TransportMaxAggregate
  _min: TransportMinAggregate
  _sum: TransportSumAggregate
  company_id: Int!
  id: Int!
  load_capacity: Int!
  owner_name: String!
  transport_date: Timestamp!
  vehicle_brand: String!
  vehicle_number: String!
  warehouse_id: Int!
  year_of_manufacture: Int!
}

input TransportListRelationFilter {
  every: TransportWhereInput
  none: TransportWhereInput
  some: TransportWhereInput
}

type TransportMaxAggregate {
  company_id: Int
  id: Int
  load_capacity: Int
  owner_name: String
  transport_date: Timestamp
  vehicle_brand: String
  vehicle_number: String
  warehouse_id: Int
  year_of_manufacture: Int
}

input TransportMaxOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  owner_name: SortOrder
  transport_date: SortOrder
  vehicle_brand: SortOrder
  vehicle_number: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

type TransportMinAggregate {
  company_id: Int
  id: Int
  load_capacity: Int
  owner_name: String
  transport_date: Timestamp
  vehicle_brand: String
  vehicle_number: String
  warehouse_id: Int
  year_of_manufacture: Int
}

input TransportMinOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  owner_name: SortOrder
  transport_date: SortOrder
  vehicle_brand: SortOrder
  vehicle_number: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

input TransportOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransportOrderByWithAggregationInput {
  _avg: TransportAvgOrderByAggregateInput
  _count: TransportCountOrderByAggregateInput
  _max: TransportMaxOrderByAggregateInput
  _min: TransportMinOrderByAggregateInput
  _sum: TransportSumOrderByAggregateInput
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  owner_name: SortOrder
  transport_date: SortOrder
  vehicle_brand: SortOrder
  vehicle_number: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

input TransportOrderByWithRelationInput {
  company: CompanyOrderByWithRelationInput
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  owner_name: SortOrder
  transport_date: SortOrder
  vehicle_brand: SortOrder
  vehicle_number: SortOrder
  warehouse: WarehouseOrderByWithRelationInput
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

enum TransportScalarFieldEnum {
  company_id
  id
  load_capacity
  owner_name
  transport_date
  vehicle_brand
  vehicle_number
  warehouse_id
  year_of_manufacture
}

input TransportScalarWhereInput {
  AND: [TransportScalarWhereInput!]
  NOT: [TransportScalarWhereInput!]
  OR: [TransportScalarWhereInput!]
  company_id: IntFilter
  id: IntFilter
  load_capacity: IntFilter
  owner_name: StringFilter
  transport_date: DateTimeFilter
  vehicle_brand: StringFilter
  vehicle_number: StringFilter
  warehouse_id: IntFilter
  year_of_manufacture: IntFilter
}

input TransportScalarWhereWithAggregatesInput {
  AND: [TransportScalarWhereWithAggregatesInput!]
  NOT: [TransportScalarWhereWithAggregatesInput!]
  OR: [TransportScalarWhereWithAggregatesInput!]
  company_id: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  load_capacity: IntWithAggregatesFilter
  owner_name: StringWithAggregatesFilter
  transport_date: DateTimeWithAggregatesFilter
  vehicle_brand: StringWithAggregatesFilter
  vehicle_number: StringWithAggregatesFilter
  warehouse_id: IntWithAggregatesFilter
  year_of_manufacture: IntWithAggregatesFilter
}

type TransportSumAggregate {
  company_id: Int
  id: Int
  load_capacity: Int
  warehouse_id: Int
  year_of_manufacture: Int
}

input TransportSumOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  load_capacity: SortOrder
  warehouse_id: SortOrder
  year_of_manufacture: SortOrder
}

input TransportUpdateInput {
  company: CompanyUpdateOneRequiredWithoutTransportsNestedInput
  load_capacity: IntFieldUpdateOperationsInput
  owner_name: StringFieldUpdateOperationsInput
  transport_date: DateTimeFieldUpdateOperationsInput
  vehicle_brand: StringFieldUpdateOperationsInput
  vehicle_number: StringFieldUpdateOperationsInput
  warehouse: WarehouseUpdateOneRequiredWithoutTransportsNestedInput
  year_of_manufacture: IntFieldUpdateOperationsInput
}

input TransportUpdateManyMutationInput {
  load_capacity: IntFieldUpdateOperationsInput
  owner_name: StringFieldUpdateOperationsInput
  transport_date: DateTimeFieldUpdateOperationsInput
  vehicle_brand: StringFieldUpdateOperationsInput
  vehicle_number: StringFieldUpdateOperationsInput
  year_of_manufacture: IntFieldUpdateOperationsInput
}

input TransportUpdateManyWithWhereWithoutCompanyInput {
  data: TransportUpdateManyMutationInput!
  where: TransportScalarWhereInput!
}

input TransportUpdateManyWithWhereWithoutWarehouseInput {
  data: TransportUpdateManyMutationInput!
  where: TransportScalarWhereInput!
}

input TransportUpdateManyWithoutCompanyNestedInput {
  connect: [TransportWhereUniqueInput!]
  connectOrCreate: [TransportCreateOrConnectWithoutCompanyInput!]
  create: [TransportCreateWithoutCompanyInput!]
  createMany: TransportCreateManyCompanyInputEnvelope
  delete: [TransportWhereUniqueInput!]
  deleteMany: [TransportScalarWhereInput!]
  disconnect: [TransportWhereUniqueInput!]
  set: [TransportWhereUniqueInput!]
  update: [TransportUpdateWithWhereUniqueWithoutCompanyInput!]
  updateMany: [TransportUpdateManyWithWhereWithoutCompanyInput!]
  upsert: [TransportUpsertWithWhereUniqueWithoutCompanyInput!]
}

input TransportUpdateManyWithoutWarehouseNestedInput {
  connect: [TransportWhereUniqueInput!]
  connectOrCreate: [TransportCreateOrConnectWithoutWarehouseInput!]
  create: [TransportCreateWithoutWarehouseInput!]
  createMany: TransportCreateManyWarehouseInputEnvelope
  delete: [TransportWhereUniqueInput!]
  deleteMany: [TransportScalarWhereInput!]
  disconnect: [TransportWhereUniqueInput!]
  set: [TransportWhereUniqueInput!]
  update: [TransportUpdateWithWhereUniqueWithoutWarehouseInput!]
  updateMany: [TransportUpdateManyWithWhereWithoutWarehouseInput!]
  upsert: [TransportUpsertWithWhereUniqueWithoutWarehouseInput!]
}

input TransportUpdateWithWhereUniqueWithoutCompanyInput {
  data: TransportUpdateWithoutCompanyInput!
  where: TransportWhereUniqueInput!
}

input TransportUpdateWithWhereUniqueWithoutWarehouseInput {
  data: TransportUpdateWithoutWarehouseInput!
  where: TransportWhereUniqueInput!
}

input TransportUpdateWithoutCompanyInput {
  load_capacity: IntFieldUpdateOperationsInput
  owner_name: StringFieldUpdateOperationsInput
  transport_date: DateTimeFieldUpdateOperationsInput
  vehicle_brand: StringFieldUpdateOperationsInput
  vehicle_number: StringFieldUpdateOperationsInput
  warehouse: WarehouseUpdateOneRequiredWithoutTransportsNestedInput
  year_of_manufacture: IntFieldUpdateOperationsInput
}

input TransportUpdateWithoutWarehouseInput {
  company: CompanyUpdateOneRequiredWithoutTransportsNestedInput
  load_capacity: IntFieldUpdateOperationsInput
  owner_name: StringFieldUpdateOperationsInput
  transport_date: DateTimeFieldUpdateOperationsInput
  vehicle_brand: StringFieldUpdateOperationsInput
  vehicle_number: StringFieldUpdateOperationsInput
  year_of_manufacture: IntFieldUpdateOperationsInput
}

input TransportUpsertWithWhereUniqueWithoutCompanyInput {
  create: TransportCreateWithoutCompanyInput!
  update: TransportUpdateWithoutCompanyInput!
  where: TransportWhereUniqueInput!
}

input TransportUpsertWithWhereUniqueWithoutWarehouseInput {
  create: TransportCreateWithoutWarehouseInput!
  update: TransportUpdateWithoutWarehouseInput!
  where: TransportWhereUniqueInput!
}

input TransportWhereInput {
  AND: [TransportWhereInput!]
  NOT: [TransportWhereInput!]
  OR: [TransportWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  id: IntFilter
  load_capacity: IntFilter
  owner_name: StringFilter
  transport_date: DateTimeFilter
  vehicle_brand: StringFilter
  vehicle_number: StringFilter
  warehouse: WarehouseRelationFilter
  warehouse_id: IntFilter
  year_of_manufacture: IntFilter
}

input TransportWhereUniqueInput {
  AND: [TransportWhereInput!]
  NOT: [TransportWhereInput!]
  OR: [TransportWhereInput!]
  company: CompanyRelationFilter
  company_id: IntFilter
  id: Int
  load_capacity: IntFilter
  owner_name: StringFilter
  transport_date: DateTimeFilter
  vehicle_brand: StringFilter
  vehicle_number: StringFilter
  warehouse: WarehouseRelationFilter
  warehouse_id: IntFilter
  year_of_manufacture: IntFilter
}

type Warehouse {
  _count: WarehouseCount
  address: String!
  company_id: Int!
  id: Int!
  order_id: Int!
}

type WarehouseAvgAggregate {
  company_id: Float
  id: Float
  order_id: Float
}

input WarehouseAvgOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

type WarehouseCount {
  transports(where: TransportWhereInput): Int!
}

type WarehouseCountAggregate {
  _all: Int!
  address: Int!
  company_id: Int!
  id: Int!
  order_id: Int!
}

input WarehouseCountOrderByAggregateInput {
  address: SortOrder
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

input WarehouseCreateInput {
  address: String!
  company: CompanyCreateNestedOneWithoutWarehousesInput!
  order: OrderCreateNestedOneWithoutWarehouseInput!
  transports: TransportCreateNestedManyWithoutWarehouseInput
}

input WarehouseCreateManyCompanyInput {
  address: String!
  id: Int
  order_id: Int!
}

input WarehouseCreateManyCompanyInputEnvelope {
  data: [WarehouseCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input WarehouseCreateManyInput {
  address: String!
  company_id: Int!
  id: Int
  order_id: Int!
}

input WarehouseCreateManyOrderInput {
  address: String!
  company_id: Int!
  id: Int
}

input WarehouseCreateManyOrderInputEnvelope {
  data: [WarehouseCreateManyOrderInput!]!
  skipDuplicates: Boolean
}

input WarehouseCreateNestedManyWithoutCompanyInput {
  connect: [WarehouseWhereUniqueInput!]
  connectOrCreate: [WarehouseCreateOrConnectWithoutCompanyInput!]
  create: [WarehouseCreateWithoutCompanyInput!]
  createMany: WarehouseCreateManyCompanyInputEnvelope
}

input WarehouseCreateNestedManyWithoutOrderInput {
  connect: [WarehouseWhereUniqueInput!]
  connectOrCreate: [WarehouseCreateOrConnectWithoutOrderInput!]
  create: [WarehouseCreateWithoutOrderInput!]
  createMany: WarehouseCreateManyOrderInputEnvelope
}

input WarehouseCreateNestedOneWithoutTransportsInput {
  connect: WarehouseWhereUniqueInput
  connectOrCreate: WarehouseCreateOrConnectWithoutTransportsInput
  create: WarehouseCreateWithoutTransportsInput
}

input WarehouseCreateOrConnectWithoutCompanyInput {
  create: WarehouseCreateWithoutCompanyInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseCreateOrConnectWithoutOrderInput {
  create: WarehouseCreateWithoutOrderInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseCreateOrConnectWithoutTransportsInput {
  create: WarehouseCreateWithoutTransportsInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseCreateWithoutCompanyInput {
  address: String!
  order: OrderCreateNestedOneWithoutWarehouseInput!
  transports: TransportCreateNestedManyWithoutWarehouseInput
}

input WarehouseCreateWithoutOrderInput {
  address: String!
  company: CompanyCreateNestedOneWithoutWarehousesInput!
  transports: TransportCreateNestedManyWithoutWarehouseInput
}

input WarehouseCreateWithoutTransportsInput {
  address: String!
  company: CompanyCreateNestedOneWithoutWarehousesInput!
  order: OrderCreateNestedOneWithoutWarehouseInput!
}

type WarehouseGroupBy {
  _avg: WarehouseAvgAggregate
  _count: WarehouseCountAggregate
  _max: WarehouseMaxAggregate
  _min: WarehouseMinAggregate
  _sum: WarehouseSumAggregate
  address: String!
  company_id: Int!
  id: Int!
  order_id: Int!
}

input WarehouseListRelationFilter {
  every: WarehouseWhereInput
  none: WarehouseWhereInput
  some: WarehouseWhereInput
}

type WarehouseMaxAggregate {
  address: String
  company_id: Int
  id: Int
  order_id: Int
}

input WarehouseMaxOrderByAggregateInput {
  address: SortOrder
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

type WarehouseMinAggregate {
  address: String
  company_id: Int
  id: Int
  order_id: Int
}

input WarehouseMinOrderByAggregateInput {
  address: SortOrder
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

input WarehouseOrderByRelationAggregateInput {
  _count: SortOrder
}

input WarehouseOrderByWithAggregationInput {
  _avg: WarehouseAvgOrderByAggregateInput
  _count: WarehouseCountOrderByAggregateInput
  _max: WarehouseMaxOrderByAggregateInput
  _min: WarehouseMinOrderByAggregateInput
  _sum: WarehouseSumOrderByAggregateInput
  address: SortOrder
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

input WarehouseOrderByWithRelationInput {
  address: SortOrder
  company: CompanyOrderByWithRelationInput
  company_id: SortOrder
  id: SortOrder
  order: OrderOrderByWithRelationInput
  order_id: SortOrder
  transports: TransportOrderByRelationAggregateInput
}

input WarehouseRelationFilter {
  is: WarehouseWhereInput
  isNot: WarehouseWhereInput
}

enum WarehouseScalarFieldEnum {
  address
  company_id
  id
  order_id
}

input WarehouseScalarWhereInput {
  AND: [WarehouseScalarWhereInput!]
  NOT: [WarehouseScalarWhereInput!]
  OR: [WarehouseScalarWhereInput!]
  address: StringFilter
  company_id: IntFilter
  id: IntFilter
  order_id: IntFilter
}

input WarehouseScalarWhereWithAggregatesInput {
  AND: [WarehouseScalarWhereWithAggregatesInput!]
  NOT: [WarehouseScalarWhereWithAggregatesInput!]
  OR: [WarehouseScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  company_id: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  order_id: IntWithAggregatesFilter
}

type WarehouseSumAggregate {
  company_id: Int
  id: Int
  order_id: Int
}

input WarehouseSumOrderByAggregateInput {
  company_id: SortOrder
  id: SortOrder
  order_id: SortOrder
}

input WarehouseUpdateInput {
  address: StringFieldUpdateOperationsInput
  company: CompanyUpdateOneRequiredWithoutWarehousesNestedInput
  order: OrderUpdateOneRequiredWithoutWarehouseNestedInput
  transports: TransportUpdateManyWithoutWarehouseNestedInput
}

input WarehouseUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
}

input WarehouseUpdateManyWithWhereWithoutCompanyInput {
  data: WarehouseUpdateManyMutationInput!
  where: WarehouseScalarWhereInput!
}

input WarehouseUpdateManyWithWhereWithoutOrderInput {
  data: WarehouseUpdateManyMutationInput!
  where: WarehouseScalarWhereInput!
}

input WarehouseUpdateManyWithoutCompanyNestedInput {
  connect: [WarehouseWhereUniqueInput!]
  connectOrCreate: [WarehouseCreateOrConnectWithoutCompanyInput!]
  create: [WarehouseCreateWithoutCompanyInput!]
  createMany: WarehouseCreateManyCompanyInputEnvelope
  delete: [WarehouseWhereUniqueInput!]
  deleteMany: [WarehouseScalarWhereInput!]
  disconnect: [WarehouseWhereUniqueInput!]
  set: [WarehouseWhereUniqueInput!]
  update: [WarehouseUpdateWithWhereUniqueWithoutCompanyInput!]
  updateMany: [WarehouseUpdateManyWithWhereWithoutCompanyInput!]
  upsert: [WarehouseUpsertWithWhereUniqueWithoutCompanyInput!]
}

input WarehouseUpdateManyWithoutOrderNestedInput {
  connect: [WarehouseWhereUniqueInput!]
  connectOrCreate: [WarehouseCreateOrConnectWithoutOrderInput!]
  create: [WarehouseCreateWithoutOrderInput!]
  createMany: WarehouseCreateManyOrderInputEnvelope
  delete: [WarehouseWhereUniqueInput!]
  deleteMany: [WarehouseScalarWhereInput!]
  disconnect: [WarehouseWhereUniqueInput!]
  set: [WarehouseWhereUniqueInput!]
  update: [WarehouseUpdateWithWhereUniqueWithoutOrderInput!]
  updateMany: [WarehouseUpdateManyWithWhereWithoutOrderInput!]
  upsert: [WarehouseUpsertWithWhereUniqueWithoutOrderInput!]
}

input WarehouseUpdateOneRequiredWithoutTransportsNestedInput {
  connect: WarehouseWhereUniqueInput
  connectOrCreate: WarehouseCreateOrConnectWithoutTransportsInput
  create: WarehouseCreateWithoutTransportsInput
  update: WarehouseUpdateToOneWithWhereWithoutTransportsInput
  upsert: WarehouseUpsertWithoutTransportsInput
}

input WarehouseUpdateToOneWithWhereWithoutTransportsInput {
  data: WarehouseUpdateWithoutTransportsInput!
  where: WarehouseWhereInput
}

input WarehouseUpdateWithWhereUniqueWithoutCompanyInput {
  data: WarehouseUpdateWithoutCompanyInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseUpdateWithWhereUniqueWithoutOrderInput {
  data: WarehouseUpdateWithoutOrderInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseUpdateWithoutCompanyInput {
  address: StringFieldUpdateOperationsInput
  order: OrderUpdateOneRequiredWithoutWarehouseNestedInput
  transports: TransportUpdateManyWithoutWarehouseNestedInput
}

input WarehouseUpdateWithoutOrderInput {
  address: StringFieldUpdateOperationsInput
  company: CompanyUpdateOneRequiredWithoutWarehousesNestedInput
  transports: TransportUpdateManyWithoutWarehouseNestedInput
}

input WarehouseUpdateWithoutTransportsInput {
  address: StringFieldUpdateOperationsInput
  company: CompanyUpdateOneRequiredWithoutWarehousesNestedInput
  order: OrderUpdateOneRequiredWithoutWarehouseNestedInput
}

input WarehouseUpsertWithWhereUniqueWithoutCompanyInput {
  create: WarehouseCreateWithoutCompanyInput!
  update: WarehouseUpdateWithoutCompanyInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseUpsertWithWhereUniqueWithoutOrderInput {
  create: WarehouseCreateWithoutOrderInput!
  update: WarehouseUpdateWithoutOrderInput!
  where: WarehouseWhereUniqueInput!
}

input WarehouseUpsertWithoutTransportsInput {
  create: WarehouseCreateWithoutTransportsInput!
  update: WarehouseUpdateWithoutTransportsInput!
  where: WarehouseWhereInput
}

input WarehouseWhereInput {
  AND: [WarehouseWhereInput!]
  NOT: [WarehouseWhereInput!]
  OR: [WarehouseWhereInput!]
  address: StringFilter
  company: CompanyRelationFilter
  company_id: IntFilter
  id: IntFilter
  order: OrderRelationFilter
  order_id: IntFilter
  transports: TransportListRelationFilter
}

input WarehouseWhereUniqueInput {
  AND: [WarehouseWhereInput!]
  NOT: [WarehouseWhereInput!]
  OR: [WarehouseWhereInput!]
  address: StringFilter
  company: CompanyRelationFilter
  company_id: IntFilter
  id: Int
  order: OrderRelationFilter
  order_id: IntFilter
  transports: TransportListRelationFilter
}